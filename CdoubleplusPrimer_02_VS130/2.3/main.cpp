// 2.15
// int ival = 1.01; - good
// int &rval1 = 1.01; - bad, 참조자는 참조자일뿐...
// int &rval2 = ival; - good
// int &rval3;

#include <iostream>
int main()
{
	//2.16
	{
		int i = 0, &r1 = i;
		double d = 0, &r2 = d;

		r2 = 3.14159;
		r2 = r1;
		i = r2;
		r1 = d;
	}
	//2.17
	{
		int i, &ri = i;
		i = 5; ri = 10;
		std::cout << i << " " << ri << std::endl; //10 10
	}

	//2.18
	{
		int i, *pi = &i;
		*pi = 1;
	}

	//2.19
	//참조자는 해당 변수의 별칭, 포인터는 해당 변수의 주소를 저장

	//2.20
	{
		int i = 42;
		int *p1 = &i;// p1 은 i의 주소를 저장
		*p1 = *p1 * *p1; // i = 42*42
	}

	//2.21
	{
		int i = 0;
		//double* dp = &i; // dp는 int형의 포인터므로 불가
		//int *ip = i; // i의 어드레스(참조)를 가져와야 하므로 불가
		int *p = &i;
	}

	//2.22
	{
		int i = 0, *pi = &i;
		if (pi); // pi의 주소가 존재하는 가
		if (*pi); // pi의 값이 0인가 아닌가
	}

	// 2.23
	{
		// 그럴수 없다.
		// 포인터는 말그대로 메모리를 가리키는 주소일 뿐이지, 그 주소가 유효한지 확인을 할수는 없기 때문이다.
	}

	// 2.24
	{
		//int i = 42; void *p = &i; long *lp = &i;
		// void는 모든 형을 포괄할 수 있는 타입의 키워드이기 때문에 정수타입인 i의 포인터를 가질수 있다.
		// 그러나 long같은 경우는 이미 확정되어있는 데이타타입의 포인터이기 때문에 불가능하다.
	}

	// 2.25
	{
		{
			int* ip, i, &r = i; // 포인터, 일반변수, 참조자
		}
		{
			int i, *ip = 0;  // 변수, 포인터
		}
		{
			int *ip, ip2; // 포인터, 변수
		}
	}
}